/*
 *  Parser designed by Shmuel Jacobs for Temple University Systems Programming
    and Operating Systems Lab1, Spring 2018.
    
 *  Independent program reads in CSV generated by Discrete Event simulator and 
    calculates statistics.
 *  **Do not merge into larger lab program!**. Program is independent to allow
    analysis of resulting CSV in Excel to confirm statistics are correct.
    
 *  Program would run faster if instead of working with rows, I read one char at
    a time, and created cases for ',' and '\n'. The resulting control flow would
    be incomprehensible, so I think in terms of rows, and process rows into a
    string and then the string into six runs of the atoi function to retrieve values.
    
 *  Fail conditions: This code assumes the file in is created by Event Logger.
    If given a CSV containing nubmer longer than allowance, unexpected chars,
    rows of a different size, or anything other than the six numbers expected,
    it will crash.
    Current Allowances = {timestamp:6,jobtype:2,serial:5,cpu_qlen:3,d1_qlen:3,d2_qlen:3}
 */

#include <stdio.h>
#include <stdlib.h>
#include "Event.c"

typedef struct {
    int timestamp;
    EventCode jobtype;
    int serial;
    int cpu_qlen;
    int d1_qlen;
    int d2_qlen;
} Log_Row;

/*
 *  Function contains step to perform on each row.
 *  Read in log data for analysis.
 *  Takes pointer to file containing data.
 */
void process_row(FILE*);

/*
 *  Read individual value out of comma seperated row.
 *  return  -   integer value retrieved from row.
 */
int read_row_val(char* row_chars_read, char* row_buf);

// Fields store busy times as number of ticks.
int cpu_qmax, d1_qmax, d2_qmax,

// Fields store number of jobs completed. (Called num_jobs in some notes.)
cpu_jobs_done, d1_jobs_done, d2_jobs_done,

// Fields store time busy, measured in ticks
cpu_time_busy, d1_time_busy, d2_time_busy,

// Fields store time waited for each component, to calculate response time
cpu_time_waited_for, d1_time_waited_for, d2_time_waited_for,

// Fields to hold state during processing of one row.
last_row_time = 0, current_time, current_row_duration;

// Allocate holder for rows instead of adding allocation step to process_row.
char buf[25];
char val[7];

int main(){
    FILE* log = fopen("DES-Log.csv", "r");
    
    return EXIT_SUCCESS;
}


/*
 *  Handle next row in log file.
 *  Read in row to buf.
 *  
 *  return  -   0 if no more rows, else non-zero.
 */
int process_row(FILE* log)
{
    // Check if end of file.
    if(!fgets(buf, 25, log)){
        // Leave function and return false.
        return 0;
    }
    
    char row_index;
    // Set individual values.
    current_time = read_row_val(&row_index, buf);
    current_row_duration = current_time - last_row_time;
    
}

/*
 *  Read individual value out of comma seperated row.
 *  Inputs:
    row_chars_read  -   index of last character processed (not a string;
        int* would work just as well. All I need is to pass in the index).
        Increment with the number of characters read in this call.
    row_buf         -   String holding row to get values from.
 *  Other Storage:
        val -   Holds digits in just one number, to be fed to atoi function.
 *  return  -   integer value retrieved from row.
 */
int read_row_val(char* row_chars_read, char* row_buf)
{
    char this_val_digits = 0;
    /*  
        Read digits until a comma or NL has been copied,
            updating the number of chars read, according to both the local
            variable and the input counter.
        this_val_digits records how many digits have been read for the current
        value.
    */
    for(this_val_digits = 0;
        val[this_val_digits]!=',' && val[this_val_digits]!='\n';
        this_val_digits++){
        val[this_val_digits] = row_buf[row_chars_read++];
    } // both counters should be updated to reflect number of chars read.
    
    return atoi(val);
}
